import { Injectable, Inject, NotFoundException } from '@nestjs/common';
import { IINVOICE_REPOSITORY, type IInvoiceRepository } from '../../domain/repositories/invoice.repository.interface';
import { IPATIENT_REPOSITORY, type IPatientRepository } from '../../../patients/domain/repositories/patient.repository.interface';
import { IPRODUCT_SERVICE_REPOSITORY, type IProductServiceRepository } from '../../../masters/domain/repositories/product-service.repository.interface';
import { IAGREEMENT_REPOSITORY, type IAgreementRepository } from '../../../masters/domain/repositories/agreement.repository.interface';
import { IPREPAGADA_REPOSITORY, type IPrepagadaRepository } from '../../../masters/domain/repositories/prepagada.repository.interface';
import { Invoice } from '../../domain/entities/invoice.entity';
import { InvoiceItem } from '../../domain/entities/invoice-item.entity';
import { InvoiceStatus } from '../../domain/entities/invoice-status.enum';
import { ResponsibilityStatus } from '../../domain/entities/responsibility-status.enum';
import { CreateStandaloneInvoiceDto } from '../../infrastructure/dtos/create-standalone-invoice.dto';

@Injectable()
export class CreateStandaloneInvoiceUseCase {
    constructor(
        @Inject(IINVOICE_REPOSITORY)
        private readonly invoiceRepository: IInvoiceRepository,
        @Inject(IPATIENT_REPOSITORY)
        private readonly patientRepository: IPatientRepository,
        @Inject(IPRODUCT_SERVICE_REPOSITORY)
        private readonly productServiceRepository: IProductServiceRepository,
        @Inject(IAGREEMENT_REPOSITORY)
        private readonly agreementRepository: IAgreementRepository,
        @Inject(IPREPAGADA_REPOSITORY)
        private readonly prepagadaRepository: IPrepagadaRepository,
    ) { }

    async execute(dto: CreateStandaloneInvoiceDto): Promise<Invoice> {
        const patient = await this.patientRepository.findById(dto.patientId);
        if (!patient) {
            throw new NotFoundException('Paciente no encontrado');
        }

        const prepagadaId = dto.prepagadaId || patient.prepagada;
        const invoiceItems: InvoiceItem[] = [];

        for (const itemDto of dto.items) {
            const product = await this.productServiceRepository.findById(itemDto.id);
            if (!product) {
                throw new NotFoundException(`Producto/Servicio con ID ${itemDto.id} no encontrado`);
            }

            let patientAmount = product.price * itemDto.quantity;
            let entityAmount = 0;
            let entityStatus = ResponsibilityStatus.NOT_APPLICABLE;
            const authCode = dto.authorizationCode || null;

            // Aplicar lógica de convenio si aplica
            if (prepagadaId && (dto.paymentType === 'CONVENIO' || !dto.paymentType)) {
                let resolvedPrepagadaId = prepagadaId;
                const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(resolvedPrepagadaId);

                if (!isUuid) {
                    const pp = await this.prepagadaRepository.findByName(resolvedPrepagadaId);
                    resolvedPrepagadaId = pp ? pp.id! : '';
                }

                if (resolvedPrepagadaId) {
                    const agreement = await this.agreementRepository.findByProductAndPrepagada(product.id!, resolvedPrepagadaId);
                    if (agreement) {
                        patientAmount = agreement.patientAmount * itemDto.quantity;
                        entityAmount = agreement.entityAmount * itemDto.quantity;
                        entityStatus = ResponsibilityStatus.PENDIENTE;
                    }
                }
            }

            invoiceItems.push(new InvoiceItem(
                null,
                null, // Se asignará en el mapper
                product.id!,
                product.name,
                itemDto.quantity,
                product.price,
                patientAmount,
                ResponsibilityStatus.PAGADO,
                entityAmount,
                entityStatus,
                product.price * itemDto.quantity,
                entityAmount > 0 ? authCode : null
            ));
        }

        const totalAmount = invoiceItems.reduce((sum, item) => sum + item.totalAmount, 0);

        const invoice = new Invoice(
            null,
            null, // Standalone, no appointment
            dto.patientId,
            null, // Invoice number generated by DB/Repo
            totalAmount,
            InvoiceStatus.PAGADA,
            invoiceItems
        );

        return await this.invoiceRepository.save(invoice);
    }
}
